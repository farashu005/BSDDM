#' Run the Bayesian SDDM model with HMC
#'
#' This function prepares a dataset, initializes priors, loads necessary C++ functions,
#' and runs a Bayesian Semi-parametric Drift Diffusion Model (SSDDM) using Hamiltonian Monte Carlo (HMC).
#'
#' @param save_location Directory to save all model outputs
#' @param dat Input data frame with stop-signal and go-trial information
#' @param cluster_label Cluster label used to subset the data
#' @param Anxiety_status Group label used to subset the data
#' @param sub_type Subtype category used to subset the data
#' @param sample_size Number of subjects to sample from the subset
#' @param file_name File path to save the model output (RDS)
#' @param prep_data_file_name File path to save the preprocessed data (RDS)
#' @param range_main_eff Prior range for main effects
#' @param range_p,range_d,range_stop_prob Prior ranges for penalty, delta, and stop probability
#' @param range_rand_eff,range_rand_g_l,range_rand_g_r,range_rand_b_l,range_rand_b_r Ranges for random effects
#' @param penal_param.int Initial penalty parameters
#' @param delta_prime.int Initial delta prime parameters
#' @param stop_param.int Initial stop parameters
#' @param prob_param.int Initial probability parameters
#' @param rand_param_g_l.int,rand_param_g_r.int,rand_param_b_l.int,rand_param_b_r.int Initial random parameters
#' @param nu_d Degrees of freedom for random effect prior
#' @param kappa Shape parameter for inverse gamma prior
#' @param a,b Hyperparameters for the prior
#' @param CA_threshold Threshold for subject-level choice accuracy
#' @param nknots Number of spline knots
#' @param m Number of basis functions
#' @param scale Rescaling factor
#' @param SSD_min Minimum Stop Signal Delay
#' @param upper_bound Upper bound for integration
#' @param L Number of leapfrog steps
#' @param leapmax Maximum leap size
#' @param thin Thinning interval
#' @param nparall Number of parallel threads
#' @param nhmc Number of HMC iterations
#' @param intercept Logical. Whether to include intercept terms in spline
#'
#' @return Saves two RDS files: one with preprocessed data and another with the model output
#' @export


code_run<-function(save_location,dat,cluster_label,Anxiety_status,sub_type,sample_size,run,file_name,

                   prep_data_file_name,

                   range_main_eff,range_p,range_d,range_stop_prob,range_rand_eff,
                   range_rand_g_l,range_rand_g_r,range_rand_b_l,range_rand_b_r,

                   penal_param.int,delta_prime.int,stop_param.int,prob_param.int,
                   rand_param_g_l.int,rand_param_g_r.int,rand_param_b_l.int,rand_param_b_r.int,


                   nu_d, kappa, a, b,
                   CA_threshold, nknots, m, scale,
                   SSD_min, upper_bound,
                   L, leapmax, thin, nparall, nhmc,intercept){





  setwd(save_location)

  if (intercept == TRUE) {
    source(system.file("scripts", "Data_Preparation_with_intercept.R", package = "BSDDM"), echo = TRUE)
  } else {
    source(system.file("scripts", "Data_Preparation_without_intercept.R", package = "BSDDM"), echo = TRUE)
  }






  subset<-dat[dat$cluster_label==cluster_label & dat$Anxiety_status==Anxiety_status & dat$sub_type==sub_type,]


  f <- function(x) mean(x, na.rm = TRUE)

  CA_sub<-na.omit(aggregate(subset$sst_choiceacc,list(subset$subject),f))

  colnames(CA_sub)<-c("Sub","PER")



  ## Selecting Subjects
  # set.seed(1235)
  set.seed(5151)
  sub <- sample(CA_sub$Sub[CA_sub$PER>=CA_threshold], sample_size)


  ## Creating Dataset with the subjects
  M_I1_Non_Anx_dat<-data_prep(subset,sub=sub,nknots,m,run,scale)


  saveRDS(M_I1_Non_Anx_dat, file = prep_data_file_name)


  ## Basic Variables
  T=M_I1_Non_Anx_dat$T
  Time=M_I1_Non_Anx_dat$Time ## Time-subject wise
  X=M_I1_Non_Anx_dat$X ##. Time-combined
  X1=M_I1_Non_Anx_dat$X1 ## Spline
  Go_RT=M_I1_Non_Anx_dat$tau
  Go_RT_S=M_I1_Non_Anx_dat$tau_s
  SP_SIM_Dat=M_I1_Non_Anx_dat$sp.x1
  Ind_G=M_I1_Non_Anx_dat$Ind_G
  Indicator=M_I1_Non_Anx_dat$Ind
  T_Go=M_I1_Non_Anx_dat$T_Go
  T_Total=M_I1_Non_Anx_dat$T_Total
  FT=M_I1_Non_Anx_dat$FT
  PGF=M_I1_Non_Anx_dat$PGF


  Stop_S_D=M_I1_Non_Anx_dat$SSD

  Phi_mat=M_I1_Non_Anx_dat$Phi

  lambda<-M_I1_Non_Anx_dat$lambda

  U<-M_I1_Non_Anx_dat$U


  lower_bound<-M_I1_Non_Anx_dat$l_lim


  ## Initialization

  P=ncol(X1[[1]])
  N=length(Go_RT)
  m=length(lambda)


  mu_bl<-mu_br<-mu_gl<-mu_gr<-c(rep(0,P))
  mean_priors_main<-list(mu_gl,mu_gr,mu_bl,mu_br);

  # Function to create the Du matrix using diff
  create_Du_diff <- function(K) {
    # Initialize an empty matrix for Du
    Du <- matrix(0, nrow = K-2, ncol = K)

    # Fill the Du matrix using second-order differences
    for (i in 1:(K-2)) {
      Du[i, ] <- diff(diag(K), differences = 2)[i, ]
    }

    return(Du)
  }




  # Function to compute Pu
  compute_Pu_diff <- function(K) {
    Du <- create_Du_diff(K)
    Pu <- t(Du) %*% Du
    return(Pu)
  }

  sigma_bl_inv<-sigma_br_inv<-sigma_gl_inv<-sigma_gr_inv<-compute_Pu_diff(P)

  var_priors_main<-list(sigma_gl_inv,sigma_gr_inv,sigma_bl_inv,sigma_br_inv);


  gama_Ind<-replicate(N, matrix(0, nrow = m, ncol = 2), simplify = FALSE)
  beta_Ind<-replicate(N, matrix(0, nrow = m, ncol = 2), simplify = FALSE)



  mu_lambda_prime<-0
  sigma_lambda_prime<-1
  mu_alpha_prime<-0
  sigma_alpha_prime<-1

  mu_b_stop<-0
  sigma_b_stop<-1
  mu_nu_stop<-0
  sigma_nu_stop<-1

  prior_penal_stop<-c(mu_lambda_prime,sigma_lambda_prime,mu_alpha_prime,sigma_alpha_prime,
                      mu_b_stop,sigma_b_stop,mu_nu_stop,sigma_nu_stop)





  sigma<-1



  prob_hyp<-c(1,1,1)



  ranges<-list(range_main_eff,range_p,range_d,range_stop_prob,range_rand_eff,range_rand_g_l,range_rand_g_r,range_rand_b_l,range_rand_b_r)


  data<-M_I1_Non_Anx_dat$dat


  mean <- tapply(data$sst_primaryrt[data$sst_expcon == "GoTrial" | data$sst_inhibitacc == 0],
                 data$sst_primaryresp[data$sst_expcon == "GoTrial" | data$sst_inhibitacc == 0],
                 mean, na.rm = TRUE)

  mean <- mean[mean != 0]

  var <- tapply(data$sst_go_rt[data$sst_expcon == "GoTrial" | data$sst_inhibitacc == 0],
                data$sst_primaryresp[data$sst_expcon == "GoTrial" | data$sst_inhibitacc == 0],
                var, na.rm = TRUE)

  var <- var[var != 0]



  nu_hat<-sqrt(mean/var)

  b_hat<-nu_hat*mean


  SP2=Reduce(rbind,X1)

  if (intercept == TRUE) {
    source(system.file("scripts", "Method of Moment Method_with_intercept.R", package = "BSDDM"))
  } else {
    source(system.file("scripts", "Method_of_Moment_Method_without_intercept.R", package = "BSDDM"))
  }


  gama_l<-init_Gen_b(b_hat[1],SP2)
  gama_r<-init_Gen_b(b_hat[2],SP2)
  gama.int<-matrix(c(gama_l,gama_r),ncol=2,byrow = F)


  beta_l<-init_Gen_nu(nu_hat[1],SP2)
  beta_r<-init_Gen_nu(nu_hat[2],SP2)
  beta.int<-matrix(c(beta_l,beta_r),ncol=2,byrow = F)




  shape=a+((P-1)/2)




  rate_b_l=b+(t(gama.int[,1])%*%sigma_gl_inv%*%gama.int[,1])/2
  rate_b_r=b+(t(gama.int[,2])%*%sigma_gl_inv%*%gama.int[,2])/2

  rate_nu_l=b+(t(beta.int[,1])%*%sigma_gl_inv%*%beta.int[,1])/2
  rate_nu_r=b+(t(beta.int[,2])%*%sigma_gl_inv%*%beta.int[,2])/2

  eta_b_l=rgamma(1,shape,1/rate_b_l)
  eta_b_r=rgamma(1,shape,1/rate_b_r)


  eta_nu_l=rgamma(1,shape,1/rate_nu_l)
  eta_nu_r=rgamma(1,shape,1/rate_nu_r)


  library(RcppArmadillo)

  print(Sys.time()); message("Starting model...")

  # Record the start time
  start_time <- Sys.time()

  set.seed(5121)

  model<-hmc(X1,Go_RT=Go_RT,Go_RT_S=Go_RT_S,SSD_min=SSD_min, U=U,Ind_G=Ind_G,Stop_S_D=Stop_S_D,
             sigma,delta_param=delta_prime.int,gama=gama.int,beta=beta.int,
             stop_param=stop_param.int,prob_param=prob_param.int,
             Indicator=Indicator,
             mean_priors_main,var_priors_main,
             penal_param.int, prior_penal_stop,
             T_Go,FT,T_Total,
             a,b,prob_hyp,
             eta_b_l,eta_b_r,eta_nu_l,eta_nu_r,
             gama_Ind,beta_Ind,
             nu_d,lambda,Phi_mat,
             rand_param_g_l.int,rand_param_g_r.int,rand_param_b_l.int,rand_param_b_r.int,
             kappa,
             ranges, L,leapmax,nhmc,thin,nparall,
             lower_bound,upper_bound,
             update_gama_beta=1,update_penalty=1,update_stop_prob=1,
             update_rand_eff=1,update_delta=1,lt=1)




  # Record the end time
  end_time <- Sys.time()

  # Calculate the duration
  (runtime <- end_time - start_time)


  print(runtime());

  saveRDS(model, file = file_name)


}
